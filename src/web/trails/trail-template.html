<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{TRAIL_NAME}} - GPX Tools</title>
  <link rel="stylesheet" href="../../styles.css">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script defer src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    .trail-header {
      margin-bottom: 2rem;
    }
    .trail-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin-top: 1rem;
    }
    .trail-meta-item {
      background: var(--bg-secondary, #f5f5f5);
      padding: 0.5rem 1rem;
      border-radius: 4px;
    }
    .trail-meta-item strong {
      display: block;
      font-size: 0.75rem;
      text-transform: uppercase;
      opacity: 0.7;
    }
    .trail-stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin: 2rem 0;
    }
    .stat-card {
      background: var(--bg-secondary, #f5f5f5);
      padding: 1rem;
      border-radius: 8px;
      text-align: center;
    }
    .stat-card .value {
      font-size: 1.5rem;
      font-weight: bold;
    }
    .stat-card .label {
      font-size: 0.875rem;
      opacity: 0.7;
    }
    .elevation-profile {
      width: 100%;
      height: 200px;
      background: var(--bg-secondary, #f5f5f5);
      border-radius: 8px;
      margin: 2rem 0;
      position: relative;
    }
    .elevation-profile canvas {
      width: 100%;
      height: 100%;
    }
    .waypoints-table-wrapper {
      overflow-x: auto;
      margin: 1rem 0;
    }
    .waypoints-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.875rem;
    }
    .waypoints-table th,
    .waypoints-table td {
      padding: 0.5rem 0.75rem;
      text-align: left;
      border-bottom: 1px solid var(--border-color, #ddd);
    }
    .waypoints-table th {
      background: var(--bg-secondary, #f5f5f5);
      font-weight: 600;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      white-space: nowrap;
    }
    .waypoints-table td.numeric {
      text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .waypoints-table tr:hover {
      background: var(--bg-secondary, #f5f5f5);
    }
    .waypoints-table tr.highlight-town {
      background: #fff3e0;
    }
    .waypoints-table tr.highlight-town:hover {
      background: #ffe0b2;
    }
    .waypoints-table tr.highlight-resupply {
      background: #e8f5e9;
    }
    .waypoints-table tr.highlight-resupply:hover {
      background: #c8e6c9;
    }
    .waypoint-type {
      font-size: 0.7rem;
      padding: 0.2rem 0.4rem;
      border-radius: 3px;
      background: var(--accent-light, #e3f2fd);
      white-space: nowrap;
    }
    .waypoint-type.type-town {
      background: #ffcc80;
    }
    .waypoint-type.type-hut {
      background: #b39ddb;
    }
    .waypoint-type.type-campsite {
      background: #a5d6a7;
    }
    .waypoint-type.type-water {
      background: #81d4fa;
    }
    .waypoint-type.type-water-tank {
      background: #80cbc4;
    }
    .waypoint-type.type-mountain {
      background: #bcaaa4;
    }
    .waypoints-list {
      list-style: none;
      padding: 0;
    }
    .waypoints-list li {
      padding: 0.75rem;
      border-bottom: 1px solid var(--border-color, #ddd);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .waypoints-list li:last-child {
      border-bottom: none;
    }
    /* Inline variant rows in waypoints table */
    .variant-row {
      background: var(--bg-secondary, #f8f9fa);
    }
    .variant-row.type-alternate {
      background: #fff8e1;
      border-left: 3px solid #ff9800;
    }
    .variant-row.type-side-trip {
      background: #fce4ec;
      border-left: 3px solid #9c27b0;
    }
    .variant-marker {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .variant-icon {
      font-size: 1.1rem;
    }
    .variant-action {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-left: 0.25rem;
    }
    .variant-inline-stats {
      font-size: 0.85rem;
      color: var(--text-secondary, #666);
    }
    .variant-stats-cell {
      text-align: left !important;
    }
    .variant-type-badge {
      display: inline-block;
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      text-transform: uppercase;
      font-weight: 600;
    }
    .variant-type-badge.type-alternate {
      background: #fff3e0;
      color: #e65100;
    }
    .variant-type-badge.type-side-trip {
      background: #f3e5f5;
      color: #7b1fa2;
    }
    .section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }
    .section-header h3 {
      margin: 0;
    }
    /* Trail map styles */
    .trail-map {
      width: 100%;
      height: 400px;
      background: var(--bg-secondary, #f5f5f5);
      border-radius: 8px;
      margin: 1rem 0 2rem 0;
      position: relative;
      z-index: 0;
    }
    .elevation-hover-marker {
      width: 12px;
      height: 12px;
      background: #ff5722;
      border: 2px solid white;
      border-radius: 50%;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    .elevation-profile .hover-line {
      position: absolute;
      top: 0;
      bottom: 30px;
      width: 2px;
      background: #ff5722;
      pointer-events: none;
      display: none;
    }
    .elevation-profile .hover-tooltip {
      position: absolute;
      top: 5px;
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      display: none;
      white-space: nowrap;
    }
    /* Waypoint marker styles */
    .waypoint-marker {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      font-size: 14px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.4);
      border: 2px solid white;
    }
    .waypoint-marker.town { background: #ffcc80; }
    .waypoint-marker.hut { background: #b39ddb; }
    .waypoint-marker.campsite { background: #a5d6a7; }
    .waypoint-marker.water { background: #81d4fa; }
    .waypoint-marker.water-tank { background: #80cbc4; }
    .waypoint-marker.mountain { background: #bcaaa4; }
    .waypoint-marker.waypoint { background: #e0e0e0; }
    @media (max-width: 768px) {
      .trail-map {
        height: 300px;
      }
    }
    @media (max-width: 480px) {
      .trail-map {
        height: 250px;
      }
    }
    .export-btn {
      padding: 0.5rem 1rem;
      background: var(--accent-color, #2196F3);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.875rem;
      transition: background 0.2s;
    }
    .export-btn:hover:not(:disabled) {
      background: var(--accent-hover, #1976D2);
    }
    .export-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <div class="container trail-data">
    <header>
      <nav class="breadcrumb">
        <a href="../../">Home</a> / <a href="../">Trails</a> / <span>{{TRAIL_SHORT_NAME}}</span>
      </nav>
    </header>

    <section class="panel active">
      <div class="trail-header">
        <h1>{{TRAIL_NAME}}</h1>
        <div class="trail-meta">
          <div class="trail-meta-item">
            <strong>Region</strong>
            {{TRAIL_REGION}}
          </div>
          <div class="trail-meta-item">
            <strong>Difficulty</strong>
            {{TRAIL_DIFFICULTY}}
          </div>
          <div class="trail-meta-item">
            <strong>Best Months</strong>
            {{TRAIL_BEST_MONTHS}}
          </div>
        </div>
      </div>

      <div class="trail-stats">
        <div class="stat-card">
          <div class="value" id="distance">--</div>
          <div class="label">Distance (km)</div>
        </div>
        <div class="stat-card">
          <div class="value" id="ascent">--</div>
          <div class="label">Total Ascent (m)</div>
        </div>
        <div class="stat-card">
          <div class="value" id="descent">--</div>
          <div class="label">Total Descent (m)</div>
        </div>
        <div class="stat-card">
          <div class="value" id="points">--</div>
          <div class="label">Track Points</div>
        </div>
      </div>

      <h3>Trail Map</h3>
      <div id="trail-map" class="trail-map"></div>

      <h3>Elevation Profile</h3>
      <div class="elevation-profile">
        <canvas id="elevation-canvas"></canvas>
      </div>

      <div class="section-header">
        <h3>Waypoints</h3>
        <button id="export-btn" class="export-btn" disabled>Export CSV</button>
      </div>
      <div class="waypoints-table-wrapper" id="waypoints-container">
        <p>Loading waypoints...</p>
      </div>
    </section>

    <footer>
      <p><a href="../">Back to Trail List</a></p>
    </footer>
  </div>

  <script type="module">
    const TRAIL_ID = '{{TRAIL_ID}}';
    const MONTH_NAMES = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

    // Map state
    let map = null;
    let hoverMarker = null;
    let mainRoutePolyline = null;
    let trackPoints = [];
    let maxDistance = 0;

    // Waypoint icon configuration (from GPX waypoints)
    const WAYPOINT_ICONS = {
      town: { icon: 'üèòÔ∏è' },
      hut: { icon: 'üõñ' },
      campsite: { icon: '‚õ∫' },
      water: { icon: 'üíß' },
      'water-tank': { icon: 'üö∞' },
      mountain: { icon: '‚õ∞Ô∏è' },
      waypoint: { icon: 'üìç' }
    };

    // Safe min/max for large arrays (avoids stack overflow with spread operator)
    function getMinMax(arr) {
      if (arr.length === 0) return { min: 0, max: 0 };
      let min = arr[0], max = arr[0];
      for (let i = 1; i < arr.length; i++) {
        if (arr[i] < min) min = arr[i];
        if (arr[i] > max) max = arr[i];
      }
      return { min, max };
    }

    // Debounce helper for resize events
    function debounce(fn, ms) {
      let timeout;
      return (...args) => {
        clearTimeout(timeout);
        timeout = setTimeout(() => fn(...args), ms);
      };
    }

    // HTML escape helper for XSS prevention
    function escapeHtml(text) {
      if (text == null) return '';
      const div = document.createElement('div');
      div.textContent = String(text);
      return div.innerHTML;
    }

    // Binary search to find nearest point by distance (O(log n) instead of O(n))
    function findNearestByDistance(points, targetDist) {
      if (points.length === 0) return 0;
      let low = 0, high = points.length - 1;

      while (low < high) {
        const mid = Math.floor((low + high) / 2);
        if (points[mid].dist < targetDist) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }

      // Check neighbors for closest
      const candidates = [low - 1, low, low + 1].filter(i => i >= 0 && i < points.length);
      return candidates.reduce((best, i) =>
        Math.abs(points[i].dist - targetDist) < Math.abs(points[best].dist - targetDist) ? i : best
      , candidates[0]);
    }

    function initMap(trail) {
      map = L.map('trail-map', {
        zoomControl: true,
        scrollWheelZoom: true
      });

      // OpenTopoMap tiles
      L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
        maxZoom: 17,
        attribution: 'Map data: &copy; OpenStreetMap contributors, SRTM | Map style: &copy; OpenTopoMap'
      }).addTo(map);

      maxDistance = trail.track.totalDistance;

      drawMainRoute(trail);
      drawAlternates(trail.alternates || []);
      drawSideTrips(trail.sideTrips || []);
      drawWaypointMarkers(trail.waypoints || []);

      // Create hover marker (initially not on map)
      hoverMarker = L.marker([0, 0], {
        icon: L.divIcon({
          className: 'elevation-hover-marker',
          iconSize: [12, 12],
          iconAnchor: [6, 6]
        })
      });

      fitMapToBounds(trail);
    }

    function drawMainRoute(trail) {
      // Use pre-simplified displayPoints for map rendering (faster)
      const displayPoints = trail.track.displayPoints || trail.track.points;
      if (!displayPoints || displayPoints.length === 0) return;

      const latLngs = displayPoints.map(p => [p.lat, p.lon]);

      mainRoutePolyline = L.polyline(latLngs, {
        color: '#2196F3',
        weight: 3,
        opacity: 0.9
      }).addTo(map);

      // Keep full points for hover sync (accurate distance lookup)
      trackPoints = trail.track.points;

      // Hover sync from map to chart
      mainRoutePolyline.on('mousemove', handleMapHover);
      mainRoutePolyline.on('mouseout', hideElevationHover);
    }

    function drawAlternates(alternates) {
      alternates.forEach(alt => {
        if (!alt.points || alt.points.length === 0) return;

        const latLngs = alt.points.map(p => [p.lat, p.lon]);
        L.polyline(latLngs, {
          color: '#ff9800',
          weight: 3,
          opacity: 0.8
        }).addTo(map).bindPopup(`<strong>${escapeHtml(alt.name)}</strong><br>${escapeHtml(alt.distance)} km`);
      });
    }

    function drawSideTrips(sideTrips) {
      sideTrips.forEach(trip => {
        if (!trip.points || trip.points.length === 0) return;

        const latLngs = trip.points.map(p => [p.lat, p.lon]);
        L.polyline(latLngs, {
          color: '#9c27b0',
          weight: 3,
          opacity: 0.8
        }).addTo(map).bindPopup(`<strong>${escapeHtml(trip.name)}</strong><br>${escapeHtml(trip.distance)} km`);
      });
    }

    function createWaypointIcon(type) {
      const config = WAYPOINT_ICONS[type] || WAYPOINT_ICONS.waypoint;
      return L.divIcon({
        className: `waypoint-marker ${type || 'waypoint'}`,
        html: config.icon,
        iconSize: [24, 24],
        iconAnchor: [12, 12],
        popupAnchor: [0, -12]
      });
    }

    function drawWaypointMarkers(waypoints) {
      if (!waypoints || waypoints.length === 0) return;

      waypoints.forEach(wp => {
        L.marker([wp.lat, wp.lon], {
          icon: createWaypointIcon(wp.type)
        }).addTo(map).bindPopup(`
          <strong>${escapeHtml(wp.name || 'Waypoint')}</strong><br>
          ${escapeHtml(wp.type || 'waypoint')}<br>
          ${(wp.totalDistance || 0).toFixed(1)} km along trail
          ${wp.elevation ? `<br>${Math.round(wp.elevation)}m elevation` : ''}
        `);
      });
    }

    function fitMapToBounds(trail) {
      const bounds = L.latLngBounds();

      // Use displayPoints for faster bounds calculation (fewer iterations)
      const displayPoints = trail.track.displayPoints || trail.track.points;
      displayPoints.forEach(p => bounds.extend([p.lat, p.lon]));

      (trail.alternates || []).forEach(alt => {
        (alt.points || []).forEach(p => bounds.extend([p.lat, p.lon]));
      });

      (trail.sideTrips || []).forEach(trip => {
        (trip.points || []).forEach(p => bounds.extend([p.lat, p.lon]));
      });

      map.fitBounds(bounds, { padding: [20, 20] });
    }

    // Bidirectional hover sync
    function handleMapHover(e) {
      if (!trackPoints.length) return;

      const latlng = e.latlng;
      let nearestPoint = null;
      let minDist = Infinity;

      for (const p of trackPoints) {
        const dist = Math.sqrt(
          Math.pow(p.lat - latlng.lat, 2) +
          Math.pow(p.lon - latlng.lng, 2)
        );
        if (dist < minDist) {
          minDist = dist;
          nearestPoint = p;
        }
      }

      if (nearestPoint) {
        showElevationHover(nearestPoint.dist, nearestPoint.ele);
      }
    }

    function showElevationHover(distance, elevation) {
      const canvas = document.getElementById('elevation-canvas');
      const rect = canvas.getBoundingClientRect();
      const padding = { top: 20, right: 20, bottom: 30, left: 50 };
      const width = rect.width - padding.left - padding.right;

      const xPos = padding.left + (distance / maxDistance) * width;

      const hoverLine = document.querySelector('.elevation-profile .hover-line');
      const tooltip = document.querySelector('.elevation-profile .hover-tooltip');

      if (hoverLine) {
        hoverLine.style.left = `${xPos}px`;
        hoverLine.style.display = 'block';
      }

      if (tooltip) {
        tooltip.style.left = `${xPos + 10}px`;
        tooltip.textContent = `${distance.toFixed(1)} km, ${Math.round(elevation)}m`;
        tooltip.style.display = 'block';
      }
    }

    function hideElevationHover() {
      const hoverLine = document.querySelector('.elevation-profile .hover-line');
      const tooltip = document.querySelector('.elevation-profile .hover-tooltip');
      if (hoverLine) hoverLine.style.display = 'none';
      if (tooltip) tooltip.style.display = 'none';
    }

    function setupElevationHover() {
      const canvas = document.getElementById('elevation-canvas');
      const profileDiv = document.querySelector('.elevation-profile');

      // Add hover line and tooltip elements
      const hoverLine = document.createElement('div');
      hoverLine.className = 'hover-line';
      profileDiv.appendChild(hoverLine);

      const tooltip = document.createElement('div');
      tooltip.className = 'hover-tooltip';
      profileDiv.appendChild(tooltip);

      canvas.addEventListener('mousemove', (e) => {
        if (!trackPoints.length || !map) return;

        const rect = canvas.getBoundingClientRect();
        const padding = { top: 20, right: 20, bottom: 30, left: 50 };
        const width = rect.width - padding.left - padding.right;

        const x = e.clientX - rect.left - padding.left;
        if (x < 0 || x > width) {
          hideElevationHover();
          if (map.hasLayer(hoverMarker)) map.removeLayer(hoverMarker);
          return;
        }

        const distance = (x / width) * maxDistance;

        // Binary search for nearest point by distance (O(log n))
        const nearestIndex = findNearestByDistance(trackPoints, distance);
        const nearestPoint = trackPoints[nearestIndex];

        if (nearestPoint) {
          hoverMarker.setLatLng([nearestPoint.lat, nearestPoint.lon]);
          if (!map.hasLayer(hoverMarker)) {
            hoverMarker.addTo(map);
          }
          showElevationHover(nearestPoint.dist, nearestPoint.ele);
        }
      });

      canvas.addEventListener('mouseleave', () => {
        if (map && map.hasLayer(hoverMarker)) {
          map.removeLayer(hoverMarker);
        }
        hideElevationHover();
      });
    }

    async function loadTrailData() {
      try {
        const response = await fetch(`../../data/generated/${TRAIL_ID}.json`);
        if (!response.ok) throw new Error('Trail data not found');
        return await response.json();
      } catch (error) {
        console.error('Failed to load trail data:', error);
        return null;
      }
    }

    function updateStats(trail) {
      document.getElementById('distance').textContent = trail.track.totalDistance.toFixed(1);
      document.getElementById('ascent').textContent = Math.round(trail.track.totalAscent);
      document.getElementById('descent').textContent = Math.round(trail.track.totalDescent);
      document.getElementById('points').textContent = trail.track.points.length.toLocaleString();
    }

    function drawElevationProfile(points) {
      const canvas = document.getElementById('elevation-canvas');
      const ctx = canvas.getContext('2d');
      const rect = canvas.getBoundingClientRect();

      canvas.width = rect.width * window.devicePixelRatio;
      canvas.height = rect.height * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

      if (points.length === 0) return;

      const elevations = points.map(p => p.ele);
      const distances = points.map(p => p.dist);
      const { min: minEle, max: maxEle } = getMinMax(elevations);
      const { max: maxDist } = getMinMax(distances);

      const padding = { top: 20, right: 20, bottom: 30, left: 50 };
      const width = rect.width - padding.left - padding.right;
      const height = rect.height - padding.top - padding.bottom;

      // Draw grid
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;
      for (let i = 0; i <= 4; i++) {
        const y = padding.top + (height / 4) * i;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(padding.left + width, y);
        ctx.stroke();
      }

      // Draw profile
      ctx.beginPath();
      ctx.strokeStyle = '#2196F3';
      ctx.lineWidth = 2;

      points.forEach((point, i) => {
        const x = padding.left + (point.dist / maxDist) * width;
        const y = padding.top + height - ((point.ele - minEle) / (maxEle - minEle)) * height;

        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      ctx.stroke();

      // Fill under curve
      ctx.lineTo(padding.left + width, padding.top + height);
      ctx.lineTo(padding.left, padding.top + height);
      ctx.closePath();
      ctx.fillStyle = 'rgba(33, 150, 243, 0.1)';
      ctx.fill();

      // Draw labels
      ctx.fillStyle = '#666';
      ctx.font = '12px system-ui, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(`${Math.round(maxEle)}m`, padding.left - 5, padding.top + 10);
      ctx.fillText(`${Math.round(minEle)}m`, padding.left - 5, padding.top + height);

      ctx.textAlign = 'center';
      ctx.fillText('0 km', padding.left, padding.top + height + 20);
      ctx.fillText(`${maxDist.toFixed(0)} km`, padding.left + width, padding.top + height + 20);
    }

    function renderWaypoints(waypoints, alternates, sideTrips) {
      const container = document.getElementById('waypoints-container');

      if (!waypoints || waypoints.length === 0) {
        container.innerHTML = '<p>No waypoints defined</p>';
        return;
      }

      // Resupply keywords to detect resupply points
      const resupplyKeywords = ['grocer', 'market', 'foodland', 'iga', 'wool', 'coles', 'general', 'servo'];

      function isResupply(wp) {
        const text = ((wp.name || '') + ' ' + (wp.description || '')).toLowerCase();
        return resupplyKeywords.some(kw => text.includes(kw));
      }

      function getRowClass(wp) {
        if (wp.type === 'town') return 'highlight-town';
        if (isResupply(wp)) return 'highlight-resupply';
        return '';
      }

      function getTypeClass(type) {
        const typeMap = {
          'town': 'type-town',
          'hut': 'type-hut',
          'campsite': 'type-campsite',
          'water': 'type-water',
          'water-tank': 'type-water-tank',
          'mountain': 'type-mountain'
        };
        return typeMap[type] || '';
      }

      // Build a combined list of waypoints and variant markers, sorted by distance
      const allVariants = [...(alternates || []), ...(sideTrips || [])];
      const tableRows = [];

      // Add waypoints
      for (const wp of waypoints) {
        tableRows.push({
          rowType: 'waypoint',
          distance: wp.totalDistance ?? 0,
          data: wp
        });
      }

      // Add variant start/end markers
      for (const variant of allVariants) {
        if (variant.startDistance != null) {
          tableRows.push({
            rowType: 'variant-start',
            distance: variant.startDistance,
            data: variant
          });
        }
        // For alternates, add rejoin marker
        if (variant.type === 'alternate' && variant.endDistance != null) {
          tableRows.push({
            rowType: 'variant-end',
            distance: variant.endDistance,
            data: variant
          });
        }
      }

      // Sort by distance along route
      tableRows.sort((a, b) => a.distance - b.distance);

      function renderWaypointRow(wp) {
        return `
          <tr class="${getRowClass(wp)}">
            <td>${wp.name || 'Unnamed'}</td>
            <td><span class="waypoint-type ${getTypeClass(wp.type)}">${wp.type || 'waypoint'}</span></td>
            <td class="numeric">${wp.elevation ?? '-'}</td>
            <td class="numeric">${wp.distance?.toFixed(1) ?? '-'}</td>
            <td class="numeric">${wp.totalDistance?.toFixed(1) ?? '-'}</td>
            <td class="numeric">${wp.ascent ?? '-'}</td>
            <td class="numeric">${wp.descent ?? '-'}</td>
            <td class="numeric">${wp.totalAscent ?? '-'}</td>
            <td class="numeric">${wp.totalDescent ?? '-'}</td>
          </tr>
        `;
      }

      function renderVariantRow(variant, isStart) {
        const typeClass = variant.type === 'alternate' ? 'type-alternate' : 'type-side-trip';
        const typeLabel = variant.type === 'alternate' ? 'Alternate' : 'Side Trip';
        const actionLabel = isStart
          ? (variant.type === 'alternate' ? 'branches' : 'starts')
          : 'rejoins';
        const distance = isStart ? variant.startDistance : variant.endDistance;

        return `
          <tr class="variant-row ${typeClass}">
            <td colspan="2">
              <span class="variant-marker ${typeClass}">
                <span class="variant-icon">${isStart ? '‚Üó' : '‚Üò'}</span>
                <strong>${variant.name}</strong>
                <span class="variant-action">${actionLabel} here</span>
              </span>
            </td>
            <td colspan="3" class="variant-stats-cell">
              <span class="variant-inline-stats">
                ${variant.distance} km ¬∑ +${variant.elevation?.ascent || 0}m / -${variant.elevation?.descent || 0}m
              </span>
            </td>
            <td class="numeric">${distance?.toFixed(1) ?? '-'}</td>
            <td colspan="3">
              <span class="variant-type-badge ${typeClass}">${typeLabel}</span>
            </td>
          </tr>
        `;
      }

      const tableHtml = `
        <table class="waypoints-table">
          <thead>
            <tr>
              <th>Location</th>
              <th>Type</th>
              <th>Elev (m)</th>
              <th>Dist (km)</th>
              <th>Total (km)</th>
              <th>Gain (m)</th>
              <th>Loss (m)</th>
              <th>Total Gain</th>
              <th>Total Loss</th>
            </tr>
          </thead>
          <tbody>
            ${tableRows.map(row => {
              if (row.rowType === 'waypoint') {
                return renderWaypointRow(row.data);
              } else if (row.rowType === 'variant-start') {
                return renderVariantRow(row.data, true);
              } else {
                return renderVariantRow(row.data, false);
              }
            }).join('')}
          </tbody>
        </table>
      `;

      container.innerHTML = tableHtml;
    }

    function exportDatasheet(trail) {
      const { config, track, waypoints, alternates, sideTrips } = trail;

      // Build CSV content
      const lines = [];

      // Header with trail info
      lines.push(`# ${config.name} - Trail Datasheet`);
      lines.push(`# Region: ${config.region}`);
      lines.push(`# Total Distance: ${track.totalDistance.toFixed(1)} km`);
      lines.push(`# Total Ascent: ${Math.round(track.totalAscent)} m`);
      lines.push(`# Total Descent: ${Math.round(track.totalDescent)} m`);
      lines.push(`# Generated: ${new Date().toISOString().split('T')[0]}`);
      lines.push('');

      // Waypoints table header
      lines.push('Location,Type,Elevation (m),Distance (km),Total (km),Gain (m),Loss (m),Total Gain (m),Total Loss (m),Notes');

      // Add waypoints
      for (const wp of waypoints || []) {
        const row = [
          `"${(wp.name || 'Unnamed').replace(/"/g, '""')}"`,
          wp.type || 'waypoint',
          wp.elevation ?? '',
          wp.distance?.toFixed(1) ?? '',
          wp.totalDistance?.toFixed(1) ?? '',
          wp.ascent ?? '',
          wp.descent ?? '',
          wp.totalAscent ?? '',
          wp.totalDescent ?? '',
          `"${(wp.description || '').replace(/"/g, '""')}"`
        ];
        lines.push(row.join(','));
      }

      // Add alternates section if present
      if (alternates && alternates.length > 0) {
        lines.push('');
        lines.push('# Alternate Routes');
        lines.push('Name,Type,Distance (km),Ascent (m),Descent (m),Start Distance (km),End Distance (km)');
        for (const alt of alternates) {
          const row = [
            `"${(alt.name || 'Unnamed').replace(/"/g, '""')}"`,
            alt.type || 'alternate',
            alt.distance ?? '',
            alt.elevation?.ascent ?? '',
            alt.elevation?.descent ?? '',
            alt.startDistance?.toFixed(1) ?? '',
            alt.endDistance?.toFixed(1) ?? ''
          ];
          lines.push(row.join(','));
        }
      }

      // Add side trips section if present
      if (sideTrips && sideTrips.length > 0) {
        lines.push('');
        lines.push('# Side Trips');
        lines.push('Name,Type,Distance (km),Ascent (m),Descent (m),Start Distance (km)');
        for (const trip of sideTrips) {
          const row = [
            `"${(trip.name || 'Unnamed').replace(/"/g, '""')}"`,
            trip.type || 'side-trip',
            trip.distance ?? '',
            trip.elevation?.ascent ?? '',
            trip.elevation?.descent ?? '',
            trip.startDistance?.toFixed(1) ?? ''
          ];
          lines.push(row.join(','));
        }
      }

      const csvContent = lines.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);

      const link = document.createElement('a');
      link.href = url;
      link.download = `${config.id || 'trail'}-datasheet.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    async function init() {
      const trail = await loadTrailData();
      if (!trail) {
        document.querySelector('.panel').innerHTML = '<p>Failed to load trail data.</p>';
        return;
      }

      updateStats(trail);
      initMap(trail);
      drawElevationProfile(trail.track.points);
      setupElevationHover();
      renderWaypoints(trail.waypoints, trail.alternates, trail.sideTrips);

      // Enable export button
      const exportBtn = document.getElementById('export-btn');
      exportBtn.disabled = false;
      exportBtn.addEventListener('click', () => exportDatasheet(trail));

      // Redraw on resize (debounced to prevent jank)
      window.addEventListener('resize', debounce(() => {
        drawElevationProfile(trail.track.points);
        if (map) map.invalidateSize();
      }, 150));
    }

    init();
  </script>
</body>
</html>
